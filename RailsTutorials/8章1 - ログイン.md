# ログイン機構
- 具体的には「ログイン→ログイン状態を保持→ブラウザが閉じられたらログイン状態を破棄」というもの
- 次に、ログイン済みのユーザーだけがアクセスできるとかそういうのをつくる


## ■セッションってなに
コンピュータ間(ブラウザとサーバー間 など)で設定される半永続的な接続  
HTTPのように一度リクエストが終われば次回まったく新しいものとなるプロトコルとは違う(上の)階層にある。ので、ログイン情報の「保持」が出来るわけだな  

というわけでRailsのsessionメソッドを使っていくよ

### Sessionコントローラを作成
```rails generate controller Sessions new```を叩いてコントローラコントローラをつくる。
sessions_controller.rbや、/sessions/new.html.erb、sessions_controller_testなどが生成されるよ

### routesにルーティングを追加
get, post, deleteリクエストを使ってそれぞれnew, create, destroyアクションに辿り着けるようにしてやるよ
```
  get    '/login',   to: 'sessions#new'
  post   '/login',   to: 'sessions#create'
  delete '/logout',  to: 'sessions#destroy'
```
### コントローラのテストを追加
sessions_controller_testが生成されているので、
デフォルトで在る```get sessions_new_url```を```get login_path```に書き換えてあげよう これで名前付きルートが使えるよ

#### 豆:ルーティングの確認
コンソールで```rails routes```を実行すると
```
   Prefix Verb   URI Pattern               Controller#Action
     root GET    /                         static_pages#home
     help GET    /help(.:format)           static_pages#help
・
・
・
```
のように現状のルーティング(URLやそれに対応するコントローラ名#アクション名など)を確認することができる。

## ■ログインフォームを作るよ
コントローラとルーティングはさっき定義したのでビューを整える（ログインフォームを書く）  
その際、ログインに失敗した時はログインフォームをもう一度表示させる。ただしActive Recordによる自動生成エラーメッセージを使う訳ではないので、フラッシュメッセージを使う

### ユーザー登録フォームとの違い
- Userモデルに値するものが無いため```@user```のようなインスタンス変数を使うことができないこと。 
- ユーザー登録フォームでは```form_for(@user)```で```/users```へのPOSTであることが判定されたが、セッションの場合は```form_for(:session, url: login_path)```のように**リソース名とURL具体的に指定する**必要がある。






