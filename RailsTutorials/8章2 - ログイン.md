# ログイン
いよいよ有効な値の送信。ブラウザを閉じると自動的に有効期限が切れるタイプのcookiesを使った一時的なセッションでログインできるようにする。  
下準備としてApplicationコントローラ(app/controllers/application_controller.rb)でSessionヘルパーを読み込むために
```include SessionsHelper```を書く。



## ■log_inメソッド
### 1. 一時ユーザ情報を保存するコードをSessionヘルパー内に書いておく
一時ユーザID(ブラウザを閉じた瞬間に有効期限が切れる)をcookiesに保存しておくには```session[:user_id] = user.id```を書く  
Sessionヘルパー(app/helpers/sessions_helper.rb)に定義したメソッドの中でこれを書いておけば、このログイン手法を様々なページで使える。  
```
module SessionsHelper
  def log_in(user)
    session[:user_id] = user.id
  end
end
```
### 2. 定義したlog_inメソッドをSessionコントローラ内のcreateアクションに書く
ちなみに```redirect_to user```でuser_url(usr)へのリダイレクトとなる。  
最終的にこうなる  
```
  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      log_in user
      redirect_to user
    else
      flash.now[:danger] = 'Invalid email/password combination'
      render 'new'
    end
  end
```
## ■現在のユーザーを取り出す～current_userメソッドの定義
ここまではユーザーIDを一時セッションの中に置けるようになっただけなので、そいつを別の頁で取り出せるようにしたい  
そこで```User.find(session[:user_id])```ではなく```User.find_by(id: session[:user_id])```を使う。  
- findの場合はIDが無効の場合に例外が発生する
- find_byの場合はIDが無効の場合にnilを返す
IDが無効というのは「ユーザが存在しない」だけでなく「ログインしていない」場合もあるため、後者の場合にnilを返してくれる```Find_by```を使うのだ

- Rubyでは、nilとfalseを除いて、あらゆるオブジェクトの論理値がtrueになるように設計されている
- ```&&```や```||```などの論理演算子を使った式の場合、演算子の左の値がtrueになった時点で処理を終了する設計になっている

というわけでSesseionヘルパー内に```current_user```メソッドを定義する

```
  def current_user
    if session[:user_id]
      @current_user ||= User.find_by(id: session[:user_id])
    end
  end
```
※とりあえず今日時点での理解は









### (今のうちからまとめを書いておく)
- APPlicationコントローラに```include SessionsHelper```を書く
- ```session[:user_id] = user.id```で一時ユーザ情報を保存できる。そしてそれをSessionsヘルパーに書いておく
